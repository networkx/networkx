#!/usr/bin/env python
"""Functions for generating fractal or self-similar graphs."""

import numpy as np
import networkx as nx


__all__ = [
    "laakso_graph",
    "sierpinski_gasket_graph",
]


def laakso_graph(k, create_using=nx.Graph):
    """Returns the Laakso graph $L_k$ [1]_, [2]_.

    The Laakso graph $L_k$ is a self-similar or fractal graph defined
    recursively over the positive integers:

    1. $L_1$ is simply two nodes joined by an edge.
    2. $L_i$ is built from $L_{i-1}$ by inserting into each edge in
       $L_{i-1}$ a 4-cycle graph:

    .. code-block:: text

        L_1 --> L_2

        0        0
        |   -->  |
        1        2
                / \
               3   4
                \ /
                 5
                 |
                 1

    Parameters
    ----------
    k : integer
        The order of the graph.
    create_using : NetworkX graph constructor, optional (default=nx.Graph)
        Graph type to create. If graph instance, then cleared before populated.

    Returns
    -------
    G : networkx Graph
        The Laakso graph $L_k$.
        Each node has a node attribute ``'pos'`` that stores its
        position as generated by this function.

    Examples
    --------
    Create and plot a Laakso graph order 5:

    >>> G = nx.laakso_graph(5)
    >>> pos = nx.get_node_attributes(G, "pos")
    >>> fig, ax = plt.subplots()
    >>> nx.draw(g, pos, node_color="gray", edge_color="black", node_size=0.1, width=0.05, ax=ax)
    >>> ax.set_aspect("equal")
    >>> plt.show()

    References
    ----------
    .. [1]: Tomi J. Laakso, Plane with A∞-Weighted Metric not Bilipschitz
            Embeddable to Rn, Bulletin of the London Mathematical Society,
            Volume 34, Issue 6, November 2002, Pages 667–676,
            https://doi.org/10.1112/S0024609302001200

    .. [2]: Dilworth, S.J., Kutzarova, D. & Ostrovskii, M.I. Analysis on
            Laakso graphs with application to the structure of transportation
            cost spaces. Positivity 25, 1403–1435 (2021).
            https://doi.org/10.1007/s11117-021-00821-w

    """

    relative_positions = 0.25 * np.array([
        [ 0, 0],
        [ 0, 1],
        [-1, 2],
        [ 1, 2],
        [ 0, 3],
        [ 0, 4]
    ])
    expansion_motif = [
        (0, 1),
        (1, 2),
        (1, 3),
        (2, 4),
        (3, 4),
        (4, 5)
    ]

    def expand(edges):
        for start_point, end_point in edges:
            dx, dy = end_point - start_point
            rotation = np.array([[dy, -dx], [dx, dy]])
            points = start_point + relative_positions @ rotation
            for ii, jj in expansion_motif:
                yield((points[ii], points[jj]))

    edges = [(np.array([0, 0]), np.array([0, 1]))]
    for _ in range(1, k):
        edges = expand(edges)

    G = _convert_to_nx_graph(np.array(list(edges)), create_using)
    return G


def sierpinski_gasket_graph(n, create_using=nx.Graph):
    """Returns the Sierpinski gasket graph (or Sierpinski triangle graph) $S_n$ [1]_, [2]_.

    The Sierpinski gasket graph is a self-similar or fractal graph defined
    recursively over the positive integers:

    1. $S_1$ is simply a triangle.
    2. $S_i$ is built by triplicating $S_{i-1}$ and arranging the three subgraphs in a triangle.

    .. code-block:: text

         S_1   -->     S_2

          2             2
         / \   -->     / \
        0 - 1         0 - 1
                     / \ / \
                    3 - 4 - 5

    Parameters
    ----------
    n : integer
        The order of the graph.
    create_using : NetworkX graph constructor, optional (default=nx.Graph)
        Graph type to create. If graph instance, then cleared before populated.

    Returns
    -------
    G : networkx Graph
        The Sierpinski gasket graph $S_n$.
        Each node has a node attribute ``'pos'`` that stores its
        position as generated by this function.

    Examples
    --------
    Create and plot a Sierpinski gasket graph order 5:

    >>> G = nx.sierpinski_gasket_graph(5)
    >>> pos = nx.get_node_attributes(G, "pos")
    >>> fig, ax = plt.subplots()
    >>> nx.draw(g, pos, node_color="gray", edge_color="black", node_size=0.1, width=0.05, ax=ax)
    >>> ax.set_aspect("equal")
    >>> plt.show()

    References
    ----------
    .. [1]: Scorer, R. S., Grundy, P. M., & Smith, C. A. B. (1944). Some
            Binary Games. The Mathematical Gazette, 28(280), 96–103.
            https://doi.org/10.2307/3606393
    .. [2]: Teguia AM, Godbole AP. Sierpi\’ nski Gasket Graphs and Some of
            Their Properties. 2005 Sep 12;1–14.
            http://arxiv.org/abs/math/0509259

    """

    def expand(edges):
        shape = np.shape(edges)
        flattened = np.reshape(edges, (-1, 2))
        width, height = np.ptp(flattened, axis=0)
        left  = (flattened + np.array([-width/2, -height])).reshape(shape)
        right = (flattened + np.array([+width/2, -height])).reshape(shape)
        combined = np.vstack([edges, left, right])
        # normalize to original extent
        combined[:, :, 1] += height
        combined /= 2
        return combined

    edges = np.array([
        [np.array([0,   0]),            np.array([1,   0])],
        [np.array([1,   0]),            np.array([0.5, np.sqrt(3)/2])],
        [np.array([0.5, np.sqrt(3)/2]), np.array([0,   0])]
    ])
    for _ in range(1, n):
        edges = expand(edges)

    G = _convert_to_nx_graph(edges, create_using)

    return G


def _convert_to_nx_graph(coordinate_pair_list, create_using):
    """Convert a graph in edge list format, in which each node is
    identified by (x_1, x_2, ..., x_d) coordinates, to a networkx Graph object
    with a 'pos' attribute.

    Parameters
    ----------
    coordinate_pair_list : (E, 2, D) array-like
        Edge list with E edges consisting of a coordinate pair in D dimensions.
    create_using : NetworkX graph constructor
        Graph type to create. If graph instance, then cleared before populated.

    Returns
    -------
    G : networkx Graph
        Each node has a node attribute ``'pos'`` that stores its coordinate.

    """

    unique_coordinates, inverse_indices = \
        np.unique(coordinate_pair_list.reshape((-1, 2)), return_inverse=True, axis=0)
    G = nx.from_edgelist(inverse_indices.reshape((-1, 2)), create_using)
    nx.set_node_attributes(G, dict(enumerate(unique_coordinates)), name="pos")
    return G
