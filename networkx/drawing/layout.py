"""
******
Layout
******

Node positioning algorithms for graph drawing.

For `random_layout()` the possible resulting shape
is a square of side [0, scale] (default: [0, 1])
Changing `center` shifts the layout by that amount.

For the other layout routines, the extent is
[center - scale, center + scale] (default: [-1, 1]).

Warning: Most layout routines have only been tested in 2-dimensions.

"""
import networkx as nx
from networkx.utils import random_state

__all__ = [
    "rescale_layout",
    "rescale_layout_dict",
    "bipartite_layout",
    "circular_layout",
    "kamada_kawai_layout",
    "random_layout",
    "shell_layout",
    "spring_layout",
    "spectral_layout",
    "planar_layout",
    "fruchterman_reingold_layout",
    "spiral_layout",
    "multipartite_layout",
    "layered_layout",
]


def _process_params(G, center, dim):
    # Some boilerplate code.
    import numpy as np

    if not isinstance(G, nx.Graph):
        empty_graph = nx.Graph()
        empty_graph.add_nodes_from(G)
        G = empty_graph

    if center is None:
        center = np.zeros(dim)
    else:
        center = np.asarray(center)

    if len(center) != dim:
        msg = "length of center coordinates must match dimension of layout"
        raise ValueError(msg)

    return G, center


def rescale_layout(pos, scale=1):
    """Returns scaled position array to (-scale, scale) in all axes.

    The function acts on NumPy arrays which hold position information.
    Each position is one row of the array. The dimension of the space
    equals the number of columns. Each coordinate in one column.

    To rescale, the mean (center) is subtracted from each axis separately.
    Then all values are scaled so that the largest magnitude value
    from all axes equals `scale` (thus, the aspect ratio is preserved).
    The resulting NumPy Array is returned (order of rows unchanged).

    Parameters
    ----------
    pos : numpy array
        positions to be scaled. Each row is a position.

    scale : number (default: 1)
        The size of the resulting extent in all directions.

    Returns
    -------
    pos : numpy array
        scaled positions. Each row is a position.

    See Also
    --------
    rescale_layout_dict
    """
    # Find max length over all dimensions
    lim = 0  # max coordinate for all axes
    for i in range(pos.shape[1]):
        pos[:, i] -= pos[:, i].mean()
        lim = max(abs(pos[:, i]).max(), lim)
    # rescale to (-scale, scale) in all directions, preserves aspect
    if lim > 0:
        for i in range(pos.shape[1]):
            pos[:, i] *= scale / lim
    return pos


def rescale_layout_dict(pos, scale=1):
    """Return a dictionary of scaled positions keyed by node

    Parameters
    ----------
    pos : A dictionary of positions keyed by node

    scale : number (default: 1)
        The size of the resulting extent in all directions.

    Returns
    -------
    pos : A dictionary of positions keyed by node

    Examples
    --------
    >>> pos = {0: (0, 0), 1: (1, 1), 2: (0.5, 0.5)}
    >>> nx.rescale_layout_dict(pos)
    {0: (-1.0, -1.0), 1: (1.0, 1.0), 2: (0.0, 0.0)}

    >>> pos = {0: (0, 0), 1: (-1, 1), 2: (-0.5, 0.5)}
    >>> nx.rescale_layout_dict(pos, scale=2)
    {0: (2.0, -2.0), 1: (-2.0, 2.0), 2: (0.0, 0.0)}

    See Also
    --------
    rescale_layout
    """
    import numpy as np

    if not pos:  # empty_graph
        return {}
    pos_v = np.array(list(pos.values()))
    pos_v = rescale_layout(pos_v, scale=scale)
    return {k: tuple(v) for k, v in zip(pos.keys(), pos_v)}


@random_state(3)
def random_layout(G, center=None, dim=2, seed=None):
    """Position nodes uniformly at random in the unit square.

    For every node, a position is generated by choosing each of dim
    coordinates uniformly at random on the interval [0.0, 1.0).

    NumPy (http://scipy.org) is required for this function.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout.

    seed : int, RandomState instance or None  optional (default=None)
        Set the random state for deterministic node layouts.
        If int, `seed` is the seed used by the random number generator,
        if numpy.random.RandomState instance, `seed` is the random
        number generator,
        if None, the random number generator is the RandomState instance used
        by numpy.random.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.lollipop_graph(4, 3)
    >>> pos = nx.random_layout(G)

    """
    import numpy as np

    G, center = _process_params(G, center, dim)
    pos = seed.rand(len(G), dim) + center
    pos = pos.astype(np.float32)
    pos = dict(zip(G, pos))

    return pos


def circular_layout(G, scale=1, center=None, dim=2):
    # dim=2 only
    """Position nodes on a circle.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    scale : number (default: 1)
        Scale factor for positions.

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout.
        If dim>2, the remaining dimensions are set to zero
        in the returned positions.
        If dim<2, a ValueError is raised.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Raises
    ------
    ValueError
        If dim < 2

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.circular_layout(G)

    Notes
    -----
    This algorithm currently only works in two dimensions and does not
    try to minimize edge crossings.

    """
    import numpy as np

    if dim < 2:
        raise ValueError("cannot handle dimensions < 2")

    G, center = _process_params(G, center, dim)

    paddims = max(0, (dim - 2))

    if len(G) == 0:
        pos = {}
    elif len(G) == 1:
        pos = {nx.utils.arbitrary_element(G): center}
    else:
        # Discard the extra angle since it matches 0 radians.
        theta = np.linspace(0, 1, len(G) + 1)[:-1] * 2 * np.pi
        theta = theta.astype(np.float32)
        pos = np.column_stack(
            [np.cos(theta), np.sin(theta), np.zeros((len(G), paddims))]
        )
        pos = rescale_layout(pos, scale=scale) + center
        pos = dict(zip(G, pos))

    return pos


def shell_layout(G, nlist=None, rotate=None, scale=1, center=None, dim=2):
    """Position nodes in concentric circles.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    nlist : list of lists
       List of node lists for each shell.

    rotate : angle in radians (default=pi/len(nlist))
       Angle by which to rotate the starting position of each shell
       relative to the starting position of the previous shell.
       To recreate behavior before v2.5 use rotate=0.

    scale : number (default: 1)
        Scale factor for positions.

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout, currently only dim=2 is supported.
        Other dimension values result in a ValueError.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Raises
    ------
    ValueError
        If dim != 2

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> shells = [[0], [1, 2, 3]]
    >>> pos = nx.shell_layout(G, shells)

    Notes
    -----
    This algorithm currently only works in two dimensions and does not
    try to minimize edge crossings.

    """
    import numpy as np

    if dim != 2:
        raise ValueError("can only handle 2 dimensions")

    G, center = _process_params(G, center, dim)

    if len(G) == 0:
        return {}
    if len(G) == 1:
        return {nx.utils.arbitrary_element(G): center}

    if nlist is None:
        # draw the whole graph in one shell
        nlist = [list(G)]

    radius_bump = scale / len(nlist)

    if len(nlist[0]) == 1:
        # single node at center
        radius = 0.0
    else:
        # else start at r=1
        radius = radius_bump

    if rotate is None:
        rotate = np.pi / len(nlist)
    first_theta = rotate
    npos = {}
    for nodes in nlist:
        # Discard the last angle (endpoint=False) since 2*pi matches 0 radians
        theta = (
            np.linspace(0, 2 * np.pi, len(nodes), endpoint=False, dtype=np.float32)
            + first_theta
        )
        pos = radius * np.column_stack([np.cos(theta), np.sin(theta)]) + center
        npos.update(zip(nodes, pos))
        radius += radius_bump
        first_theta += rotate

    return npos


def bipartite_layout(
    G, nodes, align="vertical", scale=1, center=None, aspect_ratio=4 / 3
):
    """Position nodes in two straight lines.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    nodes : list or container
        Nodes in one node set of the bipartite graph.
        This set will be placed on left or top.

    align : string (default='vertical')
        The alignment of nodes. Vertical or horizontal.

    scale : number (default: 1)
        Scale factor for positions.

    center : array-like or None
        Coordinate pair around which to center the layout.

    aspect_ratio : number (default=4/3):
        The ratio of the width to the height of the layout.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node.

    Examples
    --------
    >>> G = nx.bipartite.gnmk_random_graph(3, 5, 10, seed=123)
    >>> top = nx.bipartite.sets(G)[0]
    >>> pos = nx.bipartite_layout(G, top)

    Notes
    -----
    This algorithm currently only works in two dimensions and does not
    try to minimize edge crossings.

    """
    import numpy as np

    if align not in ("vertical", "horizontal"):
        msg = "align must be either vertical or horizontal."
        raise ValueError(msg)

    G, center = _process_params(G, center=center, dim=2)
    if len(G) == 0:
        return {}

    height = 1
    width = aspect_ratio * height
    offset = (width / 2, height / 2)

    top = set(nodes)
    bottom = set(G) - top
    nodes = list(top) + list(bottom)

    left_xs = np.repeat(0, len(top))
    right_xs = np.repeat(width, len(bottom))
    left_ys = np.linspace(0, height, len(top))
    right_ys = np.linspace(0, height, len(bottom))

    top_pos = np.column_stack([left_xs, left_ys]) - offset
    bottom_pos = np.column_stack([right_xs, right_ys]) - offset

    pos = np.concatenate([top_pos, bottom_pos])
    pos = rescale_layout(pos, scale=scale) + center
    if align == "horizontal":
        pos = np.flip(pos, 1)
    pos = dict(zip(nodes, pos))
    return pos


@random_state(10)
def fruchterman_reingold_layout(
    G,
    k=None,
    pos=None,
    fixed=None,
    iterations=50,
    threshold=1e-4,
    weight="weight",
    scale=1,
    center=None,
    dim=2,
    seed=None,
):
    """Position nodes using Fruchterman-Reingold force-directed algorithm.

    The algorithm simulates a force-directed representation of the network
    treating edges as springs holding nodes close, while treating nodes
    as repelling objects, sometimes called an anti-gravity force.
    Simulation continues until the positions are close to an equilibrium.

    There are some hard-coded values: minimal distance between
    nodes (0.01) and "temperature" of 0.1 to ensure nodes don't fly away.
    During the simulation, `k` helps determine the distance between nodes,
    though `scale` and `center` determine the size and place after
    rescaling occurs at the end of the simulation.

    Fixing some nodes doesn't allow them to move in the simulation.
    It also turns off the rescaling feature at the simulation's end.
    In addition, setting `scale` to `None` turns off rescaling.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    k : float (default=None)
        Optimal distance between nodes.  If None the distance is set to
        1/sqrt(n) where n is the number of nodes.  Increase this value
        to move nodes farther apart.

    pos : dict or None  optional (default=None)
        Initial positions for nodes as a dictionary with node as keys
        and values as a coordinate list or tuple.  If None, then use
        random initial positions.

    fixed : list or None  optional (default=None)
        Nodes to keep fixed at initial position.
        ValueError raised if `fixed` specified and `pos` not.

    iterations : int  optional (default=50)
        Maximum number of iterations taken

    threshold: float optional (default = 1e-4)
        Threshold for relative error in node position changes.
        The iteration stops if the error is below this threshold.

    weight : string or None   optional (default='weight')
        The edge attribute that holds the numerical value used for
        the edge weight.  If None, then all edge weights are 1.

    scale : number or None (default: 1)
        Scale factor for positions. Not used unless `fixed is None`.
        If scale is None, no rescaling is performed.

    center : array-like or None
        Coordinate pair around which to center the layout.
        Not used unless `fixed is None`.

    dim : int
        Dimension of layout.

    seed : int, RandomState instance or None  optional (default=None)
        Set the random state for deterministic node layouts.
        If int, `seed` is the seed used by the random number generator,
        if numpy.random.RandomState instance, `seed` is the random
        number generator,
        if None, the random number generator is the RandomState instance used
        by numpy.random.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.spring_layout(G)

    # The same using longer but equivalent function name
    >>> pos = nx.fruchterman_reingold_layout(G)
    """
    import numpy as np

    G, center = _process_params(G, center, dim)

    if fixed is not None:
        if pos is None:
            raise ValueError("nodes are fixed without positions given")
        for node in fixed:
            if node not in pos:
                raise ValueError("nodes are fixed without positions given")
        nfixed = {node: i for i, node in enumerate(G)}
        fixed = np.asarray([nfixed[node] for node in fixed])

    if pos is not None:
        # Determine size of existing domain to adjust initial positions
        dom_size = max(coord for pos_tup in pos.values() for coord in pos_tup)
        if dom_size == 0:
            dom_size = 1
        pos_arr = seed.rand(len(G), dim) * dom_size + center

        for i, n in enumerate(G):
            if n in pos:
                pos_arr[i] = np.asarray(pos[n])
    else:
        pos_arr = None
        dom_size = 1

    if len(G) == 0:
        return {}
    if len(G) == 1:
        return {nx.utils.arbitrary_element(G.nodes()): center}

    try:
        # Sparse matrix
        if len(G) < 500:  # sparse solver for large graphs
            raise ValueError
        A = nx.to_scipy_sparse_matrix(G, weight=weight, dtype="f")
        if k is None and fixed is not None:
            # We must adjust k by domain size for layouts not near 1x1
            nnodes, _ = A.shape
            k = dom_size / np.sqrt(nnodes)
        pos = _sparse_fruchterman_reingold(
            A, k, pos_arr, fixed, iterations, threshold, dim, seed
        )
    except ValueError:
        A = nx.to_numpy_array(G, weight=weight)
        if k is None and fixed is not None:
            # We must adjust k by domain size for layouts not near 1x1
            nnodes, _ = A.shape
            k = dom_size / np.sqrt(nnodes)
        pos = _fruchterman_reingold(
            A, k, pos_arr, fixed, iterations, threshold, dim, seed
        )
    if fixed is None and scale is not None:
        pos = rescale_layout(pos, scale=scale) + center
    pos = dict(zip(G, pos))
    return pos


spring_layout = fruchterman_reingold_layout


@random_state(7)
def _fruchterman_reingold(
    A, k=None, pos=None, fixed=None, iterations=50, threshold=1e-4, dim=2, seed=None
):
    # Position nodes in adjacency matrix A using Fruchterman-Reingold
    # Entry point for NetworkX graph is fruchterman_reingold_layout()
    import numpy as np

    try:
        nnodes, _ = A.shape
    except AttributeError as e:
        msg = "fruchterman_reingold() takes an adjacency matrix as input"
        raise nx.NetworkXError(msg) from e

    if pos is None:
        # random initial positions
        pos = np.asarray(seed.rand(nnodes, dim), dtype=A.dtype)
    else:
        # make sure positions are of same type as matrix
        pos = pos.astype(A.dtype)

    # optimal distance between nodes
    if k is None:
        k = np.sqrt(1.0 / nnodes)
    # the initial "temperature"  is about .1 of domain area (=1x1)
    # this is the largest step allowed in the dynamics.
    # We need to calculate this in case our fixed positions force our domain
    # to be much bigger than 1x1
    t = max(max(pos.T[0]) - min(pos.T[0]), max(pos.T[1]) - min(pos.T[1])) * 0.1
    # simple cooling scheme.
    # linearly step down by dt on each iteration so last iteration is size dt.
    dt = t / float(iterations + 1)
    delta = np.zeros((pos.shape[0], pos.shape[0], pos.shape[1]), dtype=A.dtype)
    # the inscrutable (but fast) version
    # this is still O(V^2)
    # could use multilevel methods to speed this up significantly
    for iteration in range(iterations):
        # matrix of difference between points
        delta = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]
        # distance between points
        distance = np.linalg.norm(delta, axis=-1)
        # enforce minimum distance of 0.01
        np.clip(distance, 0.01, None, out=distance)
        # displacement "force"
        displacement = np.einsum(
            "ijk,ij->ik", delta, (k * k / distance ** 2 - A * distance / k)
        )
        # update positions
        length = np.linalg.norm(displacement, axis=-1)
        length = np.where(length < 0.01, 0.1, length)
        delta_pos = np.einsum("ij,i->ij", displacement, t / length)
        if fixed is not None:
            # don't change positions of fixed nodes
            delta_pos[fixed] = 0.0
        pos += delta_pos
        # cool temperature
        t -= dt
        err = np.linalg.norm(delta_pos) / nnodes
        if err < threshold:
            break
    return pos


@random_state(7)
def _sparse_fruchterman_reingold(
    A, k=None, pos=None, fixed=None, iterations=50, threshold=1e-4, dim=2, seed=None
):
    # Position nodes in adjacency matrix A using Fruchterman-Reingold
    # Entry point for NetworkX graph is fruchterman_reingold_layout()
    # Sparse version
    import numpy as np
    import scipy as sp
    import scipy.sparse  # call as sp.sparse

    try:
        nnodes, _ = A.shape
    except AttributeError as e:
        msg = "fruchterman_reingold() takes an adjacency matrix as input"
        raise nx.NetworkXError(msg) from e
    # make sure we have a LIst of Lists representation
    try:
        A = A.tolil()
    except AttributeError:
        A = (sp.sparse.coo_matrix(A)).tolil()

    if pos is None:
        # random initial positions
        pos = np.asarray(seed.rand(nnodes, dim), dtype=A.dtype)
    else:
        # make sure positions are of same type as matrix
        pos = pos.astype(A.dtype)

    # no fixed nodes
    if fixed is None:
        fixed = []

    # optimal distance between nodes
    if k is None:
        k = np.sqrt(1.0 / nnodes)
    # the initial "temperature"  is about .1 of domain area (=1x1)
    # this is the largest step allowed in the dynamics.
    t = max(max(pos.T[0]) - min(pos.T[0]), max(pos.T[1]) - min(pos.T[1])) * 0.1
    # simple cooling scheme.
    # linearly step down by dt on each iteration so last iteration is size dt.
    dt = t / float(iterations + 1)

    displacement = np.zeros((dim, nnodes))
    for iteration in range(iterations):
        displacement *= 0
        # loop over rows
        for i in range(A.shape[0]):
            if i in fixed:
                continue
            # difference between this row's node position and all others
            delta = (pos[i] - pos).T
            # distance between points
            distance = np.sqrt((delta ** 2).sum(axis=0))
            # enforce minimum distance of 0.01
            distance = np.where(distance < 0.01, 0.01, distance)
            # the adjacency matrix row
            Ai = np.asarray(A.getrowview(i).toarray())
            # displacement "force"
            displacement[:, i] += (
                delta * (k * k / distance ** 2 - Ai * distance / k)
            ).sum(axis=1)
        # update positions
        length = np.sqrt((displacement ** 2).sum(axis=0))
        length = np.where(length < 0.01, 0.1, length)
        delta_pos = (displacement * t / length).T
        pos += delta_pos
        # cool temperature
        t -= dt
        err = np.linalg.norm(delta_pos) / nnodes
        if err < threshold:
            break
    return pos


def kamada_kawai_layout(
    G, dist=None, pos=None, weight="weight", scale=1, center=None, dim=2
):
    """Position nodes using Kamada-Kawai path-length cost-function.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    dist : dict (default=None)
        A two-level dictionary of optimal distances between nodes,
        indexed by source and destination node.
        If None, the distance is computed using shortest_path_length().

    pos : dict or None  optional (default=None)
        Initial positions for nodes as a dictionary with node as keys
        and values as a coordinate list or tuple.  If None, then use
        circular_layout() for dim >= 2 and a linear layout for dim == 1.

    weight : string or None   optional (default='weight')
        The edge attribute that holds the numerical value used for
        the edge weight.  If None, then all edge weights are 1.

    scale : number (default: 1)
        Scale factor for positions.

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.kamada_kawai_layout(G)
    """
    import numpy as np

    G, center = _process_params(G, center, dim)
    nNodes = len(G)
    if nNodes == 0:
        return {}

    if dist is None:
        dist = dict(nx.shortest_path_length(G, weight=weight))
    dist_mtx = 1e6 * np.ones((nNodes, nNodes))
    for row, nr in enumerate(G):
        if nr not in dist:
            continue
        rdist = dist[nr]
        for col, nc in enumerate(G):
            if nc not in rdist:
                continue
            dist_mtx[row][col] = rdist[nc]

    if pos is None:
        if dim >= 3:
            pos = random_layout(G, dim=dim)
        elif dim == 2:
            pos = circular_layout(G, dim=dim)
        else:
            pos = {n: pt for n, pt in zip(G, np.linspace(0, 1, len(G)))}
    pos_arr = np.array([pos[n] for n in G])

    pos = _kamada_kawai_solve(dist_mtx, pos_arr, dim)

    pos = rescale_layout(pos, scale=scale) + center
    return dict(zip(G, pos))


def _kamada_kawai_solve(dist_mtx, pos_arr, dim):
    # Anneal node locations based on the Kamada-Kawai cost-function,
    # using the supplied matrix of preferred inter-node distances,
    # and starting locations.

    import numpy as np
    import scipy as sp
    import scipy.optimize  # call as sp.optimize

    meanwt = 1e-3
    costargs = (np, 1 / (dist_mtx + np.eye(dist_mtx.shape[0]) * 1e-3), meanwt, dim)

    optresult = sp.optimize.minimize(
        _kamada_kawai_costfn,
        pos_arr.ravel(),
        method="L-BFGS-B",
        args=costargs,
        jac=True,
    )

    return optresult.x.reshape((-1, dim))


def _kamada_kawai_costfn(pos_vec, np, invdist, meanweight, dim):
    # Cost-function and gradient for Kamada-Kawai layout algorithm
    nNodes = invdist.shape[0]
    pos_arr = pos_vec.reshape((nNodes, dim))

    delta = pos_arr[:, np.newaxis, :] - pos_arr[np.newaxis, :, :]
    nodesep = np.linalg.norm(delta, axis=-1)
    direction = np.einsum("ijk,ij->ijk", delta, 1 / (nodesep + np.eye(nNodes) * 1e-3))

    offset = nodesep * invdist - 1.0
    offset[np.diag_indices(nNodes)] = 0

    cost = 0.5 * np.sum(offset ** 2)
    grad = np.einsum("ij,ij,ijk->ik", invdist, offset, direction) - np.einsum(
        "ij,ij,ijk->jk", invdist, offset, direction
    )

    # Additional parabolic term to encourage mean position to be near origin:
    sumpos = np.sum(pos_arr, axis=0)
    cost += 0.5 * meanweight * np.sum(sumpos ** 2)
    grad += meanweight * sumpos

    return (cost, grad.ravel())


def spectral_layout(G, weight="weight", scale=1, center=None, dim=2):
    """Position nodes using the eigenvectors of the graph Laplacian.

    Using the unnormalized Laplacian, the layout shows possible clusters of
    nodes which are an approximation of the ratio cut. If dim is the number of
    dimensions then the positions are the entries of the dim eigenvectors
    corresponding to the ascending eigenvalues starting from the second one.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    weight : string or None   optional (default='weight')
        The edge attribute that holds the numerical value used for
        the edge weight.  If None, then all edge weights are 1.

    scale : number (default: 1)
        Scale factor for positions.

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.spectral_layout(G)

    Notes
    -----
    Directed graphs will be considered as undirected graphs when
    positioning the nodes.

    For larger graphs (>500 nodes) this will use the SciPy sparse
    eigenvalue solver (ARPACK).
    """
    # handle some special cases that break the eigensolvers
    import numpy as np

    G, center = _process_params(G, center, dim)

    if len(G) <= 2:
        if len(G) == 0:
            pos = np.array([])
        elif len(G) == 1:
            pos = np.array([center])
        else:
            pos = np.array([np.zeros(dim), np.array(center) * 2.0])
        return dict(zip(G, pos))
    try:
        # Sparse matrix
        if len(G) < 500:  # dense solver is faster for small graphs
            raise ValueError
        A = nx.to_scipy_sparse_matrix(G, weight=weight, dtype="d")
        # Symmetrize directed graphs
        if G.is_directed():
            A = A + np.transpose(A)
        pos = _sparse_spectral(A, dim)
    except (ImportError, ValueError):
        # Dense matrix
        A = nx.to_numpy_array(G, weight=weight)
        # Symmetrize directed graphs
        if G.is_directed():
            A += A.T
        pos = _spectral(A, dim)

    pos = rescale_layout(pos, scale=scale) + center
    pos = dict(zip(G, pos))
    return pos


def _spectral(A, dim=2):
    # Input adjacency matrix A
    # Uses dense eigenvalue solver from numpy
    import numpy as np

    try:
        nnodes, _ = A.shape
    except AttributeError as e:
        msg = "spectral() takes an adjacency matrix as input"
        raise nx.NetworkXError(msg) from e

    # form Laplacian matrix where D is diagonal of degrees
    D = np.identity(nnodes, dtype=A.dtype) * np.sum(A, axis=1)
    L = D - A

    eigenvalues, eigenvectors = np.linalg.eig(L)
    # sort and keep smallest nonzero
    index = np.argsort(eigenvalues)[1 : dim + 1]  # 0 index is zero eigenvalue
    return np.real(eigenvectors[:, index])


def _sparse_spectral(A, dim=2):
    # Input adjacency matrix A
    # Uses sparse eigenvalue solver from scipy
    # Could use multilevel methods here, see Koren "On spectral graph drawing"
    import numpy as np
    import scipy as sp
    import scipy.sparse  # call as sp.sparse
    import scipy.sparse.linalg  # call as sp.sparse.linalg

    try:
        nnodes, _ = A.shape
    except AttributeError as e:
        msg = "sparse_spectral() takes an adjacency matrix as input"
        raise nx.NetworkXError(msg) from e

    # form Laplacian matrix
    data = np.asarray(A.sum(axis=1).T)
    D = sp.sparse.spdiags(data, 0, nnodes, nnodes)
    L = D - A

    k = dim + 1
    # number of Lanczos vectors for ARPACK solver.What is the right scaling?
    ncv = max(2 * k + 1, int(np.sqrt(nnodes)))
    # return smallest k eigenvalues and eigenvectors
    eigenvalues, eigenvectors = sp.sparse.linalg.eigen.eigsh(L, k, which="SM", ncv=ncv)
    index = np.argsort(eigenvalues)[1:k]  # 0 index is zero eigenvalue
    return np.real(eigenvectors[:, index])


def planar_layout(G, scale=1, center=None, dim=2):
    """Position nodes without edge intersections.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G. If G is of type
        nx.PlanarEmbedding, the positions are selected accordingly.

    scale : number (default: 1)
        Scale factor for positions.

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Raises
    ------
    NetworkXException
        If G is not planar

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.planar_layout(G)
    """
    import numpy as np

    if dim != 2:
        raise ValueError("can only handle 2 dimensions")

    G, center = _process_params(G, center, dim)

    if len(G) == 0:
        return {}

    if isinstance(G, nx.PlanarEmbedding):
        embedding = G
    else:
        is_planar, embedding = nx.check_planarity(G)
        if not is_planar:
            raise nx.NetworkXException("G is not planar.")
    pos = nx.combinatorial_embedding_to_pos(embedding)
    node_list = list(embedding)
    pos = np.row_stack([pos[x] for x in node_list])
    pos = pos.astype(np.float64)
    pos = rescale_layout(pos, scale=scale) + center
    return dict(zip(node_list, pos))


def spiral_layout(G, scale=1, center=None, dim=2, resolution=0.35, equidistant=False):
    """Position nodes in a spiral layout.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.
    scale : number (default: 1)
        Scale factor for positions.
    center : array-like or None
        Coordinate pair around which to center the layout.
    dim : int
        Dimension of layout, currently only dim=2 is supported.
        Other dimension values result in a ValueError.
    resolution : float
        The compactness of the spiral layout returned.
        Lower values result in more compressed spiral layouts.
    equidistant : bool
        If True, nodes will be plotted equidistant from each other.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Raises
    ------
    ValueError
        If dim != 2

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.spiral_layout(G)

    Notes
    -----
    This algorithm currently only works in two dimensions.

    """
    import numpy as np

    if dim != 2:
        raise ValueError("can only handle 2 dimensions")

    G, center = _process_params(G, center, dim)

    if len(G) == 0:
        return {}
    if len(G) == 1:
        return {nx.utils.arbitrary_element(G): center}

    pos = []
    if equidistant:
        chord = 1
        step = 0.5
        theta = resolution
        for _ in range(len(G)):
            r = step * theta
            theta += chord / r
            pos.append([np.cos(theta) * r, np.sin(theta) * r])

    else:
        # set the starting angle and step
        step = 1
        angle = 0.0
        dist = 0.0
        # set the radius for the spiral to the number of nodes in the graph
        radius = len(G)

        while dist * np.hypot(np.cos(angle), np.sin(angle)) < radius:
            pos.append([dist * np.cos(angle), dist * np.sin(angle)])
            dist += step
            angle += resolution

    pos = rescale_layout(np.array(pos), scale=scale) + center

    pos = dict(zip(G, pos))

    return pos


def multipartite_layout(G, subset_key="subset", align="vertical", scale=1, center=None):
    """Position nodes in layers of straight lines.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    subset_key : string (default='subset')
        Key of node data to be used as layer subset.

    align : string (default='vertical')
        The alignment of nodes. Vertical or horizontal.

    scale : number (default: 1)
        Scale factor for positions.

    center : array-like or None
        Coordinate pair around which to center the layout.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node.

    Examples
    --------
    >>> G = nx.complete_multipartite_graph(28, 16, 10)
    >>> pos = nx.multipartite_layout(G)

    Notes
    -----
    This algorithm currently only works in two dimensions and does not
    try to minimize edge crossings.

    Network does not need to be a complete multipartite graph. As long as nodes
    have subset_key data, they will be placed in the corresponding layers.

    """
    import numpy as np

    if align not in ("vertical", "horizontal"):
        raise ValueError("align must be either vertical or horizontal.")

    G, center = _process_params(G, center=center, dim=2)
    if len(G) == 0:
        return {}

    layers = {}
    for v, data in G.nodes(data=True):
        try:
            layer = data[subset_key]
        except KeyError:
            msg = "all nodes must have subset_key (default='subset') as data"
            raise ValueError(msg)
        layers[layer] = [v] + layers.get(layer, [])

    pos = None
    nodes = []

    width = len(layers)
    for i, layer in layers.items():
        height = len(layer)
        xs = np.repeat(i, height)
        ys = np.arange(0, height, dtype=float)
        offset = ((width - 1) / 2, (height - 1) / 2)
        layer_pos = np.column_stack([xs, ys]) - offset
        if pos is None:
            pos = layer_pos
        else:
            pos = np.concatenate([pos, layer_pos])
        nodes.extend(layer)
    pos = rescale_layout(pos, scale=scale) + center
    if align == "horizontal":
        pos = np.flip(pos, 1)
    pos = dict(zip(nodes, pos))
    return pos


@nx.not_implemented_for("undirected")
@nx.not_implemented_for("multigraph")
def layered_layout(G, align="vertical", center=None, scale=1):
    """Position nodes in layers, using Sugiyama's method.

    Nodes are positioned in layers according to their order in the graph.
    Additionally, they are placed in layers so as to minimise edge crossings.

    Drawing edges so as to avoid unnecessary crossings is not yet implemented.

    Parameters
    ----------
    G : NetworkX DiGraph
        A position will be assigned to every node in G.

    align : string (default='vertical')
        The alignment of the drawn graph:
        * 'vertical' yields horizontal layers and top-to-bottom edges.
        * 'horizontal' yields vertical layers and left-to-right edges.

    center : array-like or None
        Coordinate pair around which to center the layout.

    scale : number (default: 1)
        Scale factor for positions.

    Returns
    -------
    pos : dict[node](xpos, ypos)
        A dictionary of positions keyed by node
    edges_path: dict[edge]list[](xpos, ypos)
        Paths taken by multi-layer edges to minimise crossings
    Raises
    ------
    NetworkXNotImplemented
        If G is not a directed acyclic graph.

    Examples
    --------
    >>> G = nx.gn_graph(24)
    >>> pos, edges_path = nx.layered_layout(G)
    >>> nx.draw(G, pos, edges_path=edges_path)

    Notes
    -----
    This algorithm only works for Directed Acyclic Graphs.

    `dim` parameter omitted because only dim==2 is supported.

    TODO
    ----
    * Write tests
    * Layer width minimization
        If wanted, an additional "max_width" parameter will be set by the caller.
        This requires another algorithm than current _layer_assignment.
    * Handling disconnected components
    * Cycle removal (will allow non-DAG DiGraphs to be laid out)
    * Accept weighted edges
        * Accept MultiDiGraphs (by increasing weight of multi-edges)
    """
    import numpy as np

    if align not in ("vertical", "horizontal"):
        raise ValueError("align must be either vertical or horizontal.")

    if not nx.is_directed_acyclic_graph(G):
        raise nx.NetworkXNotImplemented(
            "layered_layout is only implemented for directed acyclic graphs"
        )

    G, center = _process_params(G, center, dim=2)
    nodes_layer = _layer_assignment(G)
    Gd, nodes_layer, dummy_paths = _new_graph_with_dummy_nodes(G, nodes_layer)
    layers_order = _nodes_layer_dict_to_layers_order(nodes_layer)
    layers_order = _vertex_ordering(Gd, layers_order)
    # layers_pos: list[layer_id]list[node_id](node_pos_in_layer, node_name)
    layers_pos = _coordinate_assignmnent(Gd, layers_order)

    # Build output data for all nodes (including dummies)
    # pos: list[node_id](xpos, ypos)
    # nodes_name: list[node_id]node_name
    pos, nodes_name = [None] * len(Gd), [None] * len(Gd)
    n_layers = len(layers_pos)
    idx = 0
    for d1 in range(n_layers):
        for (d2, u) in layers_pos[d1]:
            pos[idx] = (d2, n_layers - d1 - 1) if align == "vertical" else (d1, d2)
            nodes_name[idx] = u
            idx += 1
    # Rescale, center and convert pos to output type
    pos = rescale_layout(np.array(pos, dtype=float), scale=scale) + center
    pos = dict(zip(nodes_name, pos))

    # Add dummy_nodes' positions to edges_path and prune them from pos
    edges_path = {}
    for e, path_nodes in dummy_paths.items():
        edges_path[e] = [None] * len(path_nodes)
        for i, u in enumerate(path_nodes):
            edges_path[e][i] = pos[u]
            del pos[u]

    return pos, edges_path


def _layer_assignment(G):
    """Assigns each node in G to a layer number, based on the node's ancestors

    layer(u) = 1 + max{layer(v) for v, _ in in_edges(u)}

    Based off:
    * p. 14: https://i11www.iti.kit.edu/_media/teaching/winter2016/graphvis/graphvis-ws16-v7-added-proofs.pdf
    * https://networkx.org/documentation/stable/_modules/networkx/algorithms/dag.html#topological_sort

    Returns
    -------
    nodes_layer : dict[node]int
        Layer number for each node in G
    """
    indegree_map = {v: d for v, d in G.in_degree() if d > 0}
    # These nodes have zero indegree and ready to be returned.
    zero_indegree = [v for v, d in G.in_degree() if d == 0]

    # Compute each node's layer
    nodes_layer = {}
    while zero_indegree:
        u = zero_indegree.pop()

        # Process u's direct successors
        for _, v in G.out_edges(u):
            indegree_map[v] -= 1
            if indegree_map[v] == 0:
                zero_indegree.append(v)
                del indegree_map[v]

        # Compute u's layer
        if G.in_degree(u) == 0:
            nodes_layer[u] = 0
        else:
            nodes_layer[u] = 1 + max([nodes_layer[v] for v, _ in G.in_edges(u)])

    return nodes_layer


DUMMY_KEY = "_dummy_node_for_edge"


def _new_graph_with_dummy_nodes(G, nodes_layer):
    """Split each edge spanning several layers into a path with one dummy node per layer.

    Returns
    -------
    Gd : nx.DiGraph
        Copy of G with dummy nodes and paths added
    nodes_layer : dict[node]int
        Layer number for each node in Gd
    dummy_paths : list
        New paths replacing the ones spanning several layers in Gd
    """
    Gd = G.copy()

    dummy_paths = {}
    dummy_node_id = 0
    for e in G.edges:
        from_pos = nodes_layer[e[0]]
        e_length = nodes_layer[e[1]] - from_pos

        if e_length == 1:
            continue

        # Remove existing edge from Gd
        Gd.remove_edge(*e)
        # Compute new path passing through dummy nodes
        dummy_path = [None] * (e_length - 1)
        # dummy_path[0] = e[0]
        # dummy_path[-1] = e[1]
        for i in range(e_length - 1):
            # Add dummy node to path, nodes_layer & Gd (with dummy annotation)
            dummy_node = f"dummy_{dummy_node_id}"
            dummy_path[i] = dummy_node
            nodes_layer[dummy_node] = from_pos + i + 1
            Gd.add_node(dummy_node, **{DUMMY_KEY: e})
            dummy_node_id += 1
        # Add new path to Gd and dummy_paths
        nx.add_path(Gd, [e[0]] + dummy_path + [e[1]])
        dummy_paths[e] = dummy_path

    return Gd, nodes_layer, dummy_paths


def _nodes_layer_dict_to_layers_order(nodes_layer):
    """Conversion of node-to-layer data representation.
    Parameters
    -------
    nodes_layer : dict[node]int
        Layer number for each node in G
    Returns
    -------
    layers_order: list[][]node
        ordered list of nodes in each layer
    """
    layers_order = [None] * (max(nodes_layer.values()) + 1)
    for u, l in nodes_layer.items():
        if layers_order[l] is None:
            layers_order[l] = [u]
        else:
            layers_order[l].append(u)
    return layers_order


def _vertex_ordering(G, layers_order):
    """Orders vertices in each layer to minimise edge crossings.

    Based off:
    * Gansner, Koutsofios, North & Vo, "A technique for drawing directed graphs," pp. 13-17, IIEEE Trans. Software Eng., 1993, doi: 10.1109/32.221135.
    * pp. 8-11: https://i11www.iti.kit.edu/_media/teaching/winter2016/graphvis/graphvis-ws16-v8.pdf
    """

    from copy import copy

    best_layers_order = copy(layers_order)
    for it in range(24):
        # Depending on the parity of the current iteration number,
        # the ranks are traversed from top to bottom or from bottom to top
        top_to_bot = it % 2 == 0

        layers_order = _order_layers_by_weighted_median(G, layers_order, top_to_bot)
        layers_order = _try_exchanging_adjacent_nodes(G, layers_order, top_to_bot)

        if it >= 1 and layers_order == best_layers_order:
            break
        elif _edge_crossings(G, layers_order) < _edge_crossings(G, best_layers_order):
            best_layers_order = copy(layers_order)

    return best_layers_order


def _order_layers_by_weighted_median(G, layers_order, top_to_bot):
    import collections

    def _weighted_node_median(node_neighbours, layer):
        # Sorted ranks of the ancestors that are in the previous layer
        neighbours_rank = sorted(
            [r for r, u in enumerate(layer) if u in node_neighbours]
        )
        n_neighbours = len(neighbours_rank)
        if n_neighbours == 0:
            # When a node has no direct ancestors, it must keep its current position.
            # median == -1 informs _sort_layer of the situation
            return -1
        elif n_neighbours == 1:
            return neighbours_rank[0]
        elif n_neighbours == 2:
            return sum(neighbours_rank) / 2

        midpoint = n_neighbours // 2
        if n_neighbours % 2 == 1:
            return neighbours_rank[midpoint]

        # n_neighbours > 2 and even
        left_range = neighbours_rank[midpoint - 1] - neighbours_rank[0]
        right_range = neighbours_rank[-1] - neighbours_rank[midpoint]
        return (
            neighbours_rank[midpoint - 1] * left_range
            + neighbours_rank[midpoint] * right_range
        ) / (left_range + right_range)

    def _sort_layer(layer_order, nodes_median):
        """Sort the layer by node median.
        Except for nodes having median == -1 that must not change position.
        Optimizable?
        """

        # OrderedDict remembers order of insertion
        # => correct inserts in layer_order afterwards
        fixed_nodes = collections.OrderedDict()
        list_of_tuples = []
        for (pos, u), m in zip(enumerate(layer_order), nodes_median):
            if m == -1:
                fixed_nodes[u] = pos
            else:
                list_of_tuples.append((u, m))

        list_of_tuples = sorted(list_of_tuples, key=lambda t: t[1])
        layer_order = [t[0] for t in list_of_tuples]
        for u, pos in fixed_nodes.items():
            layer_order.insert(pos, u)

        return layer_order

    if top_to_bot:
        layers_iterator = range(1, len(layers_order))
        node_neighbours = lambda u: [v for v, _ in G.in_edges(u)]
        next_layer_id = lambda l: l - 1
    else:
        layers_iterator = range(len(layers_order) - 2, -1, -1)
        node_neighbours = lambda u: [v for _, v in G.out_edges(u)]
        next_layer_id = lambda l: l + 1

    for l in layers_iterator:
        nodes_median = [0] * len(layers_order[l])
        for i, u in enumerate(layers_order[l]):
            nodes_median[i] = _weighted_node_median(
                node_neighbours(u), layers_order[next_layer_id(l)]
            )

        layers_order[l] = _sort_layer(layers_order[l], nodes_median)

    return layers_order


def _try_exchanging_adjacent_nodes(G, layers_order, top_to_bot):
    improved = True
    if top_to_bot:
        layers_iterator = range(len(layers_order))
    else:
        layers_iterator = range(len(layers_order) - 1, -1, -1)

    while improved:
        improved = False
        for l in layers_iterator:
            for i in range(len(layers_order[l]) - 1):
                # for i, u in enumerate(layers_order[l][:-1]):
                u = layers_order[l][i]
                v = layers_order[l][i + 1]
                uv_crossings = _edge_crossings_local(
                    G, layers_order, u, v, l, top_to_bot
                )
                vu_crossings = _edge_crossings_local(
                    G, layers_order, v, u, l, top_to_bot
                )
                if uv_crossings > vu_crossings:
                    improved = True
                    layers_order[l][i], layers_order[l][i + 1] = v, u
    return layers_order


def _edge_crossings_local(G, layers_order, u, v, l, top_to_bot):
    """Number of edge crossings between two nodes from the same layer.
    Assuming u's rank (in the layer) is lower than v's.
    """
    # Discard first/last layer depending on search direction
    if top_to_bot and l == len(layers_order) - 1 or not top_to_bot and l == 0:
        return 0

    if top_to_bot:
        layer = layers_order[l + 1]
        node_neighbours = lambda u: [v for _, v in G.out_edges(u)]
    else:
        layer = layers_order[l - 1]
        node_neighbours = lambda u: [v for v, _ in G.in_edges(u)]

    # Fetching rank of u (resp. v)'s neighbours in ancestor layer
    u_neighbours, v_neighbours = node_neighbours(u), node_neighbours(v)
    u_neigh_ranks, v_neigh_ranks = [], []
    for r, w in enumerate(layer):
        if w in u_neighbours:
            u_neigh_ranks.append(r)
        elif w in v_neighbours:
            v_neigh_ranks.append(r)

    # Computing number of edge crossings
    uv_edge_crossings = 0
    for u_neigh_rank in u_neigh_ranks:
        for v_neigh_rank in v_neigh_ranks:
            uv_edge_crossings += int(u_neigh_rank > v_neigh_rank)
    return uv_edge_crossings


def _edge_crossings(G, layers_order):
    """Total number of edge crossings in the graph."""
    crossings = 0
    for l in range(len(layers_order) - 1):
        for i, u in enumerate(layers_order[l]):
            for j in range(i + 1, len(layers_order[l])):
                v = layers_order[l][j]
                crossings += _edge_crossings_local(
                    G, layers_order, u, v, l, top_to_bot=True
                )
    return crossings


def _coordinate_assignmnent(G, layers_order):
    """Set in-layer node positions according to the priority heuristic from Sugiyama."""
    import numpy as np

    def node_priority(G, u, direction):
        if G.nodes[u].get(DUMMY_KEY, False):
            return np.inf
        elif direction == 1:
            return G.out_degree(u)
        else:
            return G.in_degree(u)

    def index_in_list_of_tuples(l, t1=None, t2=None):
        """Index of first item in l = [(a, b)] having a == t1 or b == t2
        Return -1 if not found."""
        for i, (tt1, tt2) in enumerate(l):
            if t1 is not None and tt1 == t1:
                return i
            if t2 is not None and tt2 == t2:
                return i
        return -1

    def neighbours_pos(G, u, direction, prev_layer_pos):
        if direction == 1:
            neighbours = [v for _, v in G.out_edges(u)]
        else:
            neighbours = [v for v, _ in G.in_edges(u)]

        neighbours_ids = [
            index_in_list_of_tuples(prev_layer_pos, t2=v) for v in neighbours
        ]

        return [prev_layer_pos[i][0] for i in neighbours_ids if i != -1]

    def move_node(G, p, u, target, layer_priorities, layer_pos, direction="both"):
        """direction = ['both', 'prev' or 'next']
        layer_priorities is sorted desc.
        layer_pos is sorted asc.
        """

        u_id = index_in_list_of_tuples(layer_pos, t2=u)
        prev_node_pos = layer_pos[u_id - 1] if u_id != 0 else None
        next_node_pos = layer_pos[u_id + 1] if u_id != len(layer_pos) - 1 else None

        # If trying to move in a single direction (recursive call) and
        # we have no neighbour in this direction OR it is far away
        # Success: update layer_pos and return
        if (
            direction == "next" or (prev_node_pos is None or prev_node_pos[0] < target)
        ) and (
            direction == "prev" or (next_node_pos is None or next_node_pos[0] > target)
        ):
            layer_pos[u_id] = (target, u)
            return layer_pos

        if (
            direction != "next"
            and prev_node_pos is not None
            and prev_node_pos[0] >= target
        ):
            # If there is a position conflict with the previous node
            prev_node = prev_node_pos[1]
            prev_node_priority_id = index_in_list_of_tuples(
                layer_priorities, t2=prev_node
            )
            prev_node_priority = layer_priorities[prev_node_priority_id][0]
            # If we have higher priority than the previous node
            if p >= prev_node_priority and target != 0:
                # Try moving the previous node in the "prev" direction
                try:
                    layer_pos = move_node(
                        G, p, prev_node, target - 1, layer_priorities, layer_pos, "prev"
                    )
                except RuntimeError:
                    # Continue if failed
                    pass
                else:
                    # Else, success: update layer_pos and return
                    layer_pos[u_id] = (target, u)
                    return layer_pos
        if (
            direction != "prev"
            and next_node_pos is not None
            and next_node_pos[0] <= target
        ):
            # If there is a position conflict with the next node
            next_node = next_node_pos[1]
            next_node_priority_id = index_in_list_of_tuples(
                layer_priorities, t2=next_node
            )
            assert next_node_priority_id != -1
            next_node_priority = layer_priorities[next_node_priority_id][0]
            # If we have higher priority than the next node
            if p >= next_node_priority:
                # Try moving the next node in the "next" direction
                try:
                    layer_pos = move_node(
                        G, p, next_node, target + 1, layer_priorities, layer_pos, "next"
                    )
                except RuntimeError:
                    # Continue if failed
                    pass
                else:
                    # Else, success: update layer_pos and return
                    layer_pos[u_id] = (target, u)
                    return layer_pos

        # If nothing worked, raise RuntimeError
        raise RuntimeError(f"Node {u} (p={p}) could not move to position {target}.")

    # pos: list[layer_id]list[node_id](node_pos_in_layer, node)
    # pos <- init_order()
    # = place each layer L_i' vertices from 0 to |L_i| - 1 in order
    n_layers = len(layers_order)
    layers_pos = [None] * n_layers
    for l, layer_order in enumerate(layers_order):
        layers_pos[l] = [None] * len(layer_order)
        for i, u in enumerate(layer_order):
            layers_pos[l][i] = (i, u)

    # Loop:
    # downwards: L_1 to L_n
    # upwards: L_(n-1) to L_0
    # downwards: L_1 to L_n
    r = (
        list(range(1, n_layers))
        + list(range(n_layers - 2, -1, -1))
        + list(range(1, n_layers))
    )
    directions = [-1] * (n_layers - 1) + [1] * (n_layers - 1) + [-1] * (n_layers - 1)

    for l, direction in zip(r, directions):
        # L_j = L_(i-1) if direction = downwards
        #       L_(i+1) if direction = upwards
        prev_layer_pos = layers_pos[l + direction]
        # For each vertex u in L_i: compute u's priority:
        #   * numpy.inf if u is dummy edge
        #   * otherwise: u's in degree if direction = downwards
        #                u's out degree if direction = upwards
        layer_priorities = sorted(
            [(node_priority(G, u, direction), u) for _, u in layers_pos[l]],
            reverse=True,
        )

        # for u in L_i in order of descending priority:
        # We try to move each layer twice in a row, which lets more moves succeed
        for p, u in layer_priorities * 2:
            # place u at median(u's L_j neighbours' positions),
            # possibly moving other nodes with lower priority.
            neigh_pos = neighbours_pos(G, u, direction, prev_layer_pos)
            if len(neigh_pos) == 0:
                continue
            target_pos = int(round(np.mean(neigh_pos)))
            # Using the floor of the mean looks nearly the same
            # target_pos = int(np.floor(np.mean(neigh_pos)))
            # Using float positions is really ugly (no minimum space b/w nodes)
            # target_pos = np.mean(neigh_pos)

            # Skip if already at desired pos
            u_id = index_in_list_of_tuples(layers_pos[l], t2=u)
            prev_pos = layers_pos[l][u_id][0]
            if target_pos == prev_pos:
                continue

            try:
                layers_pos[l] = move_node(
                    G, p, u, target_pos, layer_priorities, layers_pos[l]
                )
            except RuntimeError:
                pass

    return layers_pos
