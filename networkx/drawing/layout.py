#    Copyright (C) 2004-2016 by
#    Aric Hagberg <hagberg@lanl.gov>
#    Dan Schult <dschult@colgate.edu>
#    Pieter Swart <swart@lanl.gov>
#    All rights reserved.
#    BSD license.
#
# Authors: Aric Hagberg <aric.hagberg@gmail.com>,
#          Dan Schult <dschult@colgate.edu>
"""
******
Layout
******

Node positioning algorithms for graph drawing.

For `random_layout()` the possible resulting shape
is a square of side [0, scale] (default: [0, 1])
Changing `center` shifts the layout by that amount.

For the other layout routines, the extent is
[center - scale, center + scale] (default: [-1, 1]).

Warning: Most layout routines have only been tested in 2-dimensions.

"""
from __future__ import division
import collections
import networkx as nx

__all__ = ['circular_layout',
           'random_layout',
           'rescale_layout',
           'shell_layout',
           'spring_layout',
           'spectral_layout',
           'fruchterman_reingold_layout',
           'force_atlas_2_layout',
           'generalized_fruchterman_reingold_layout',
           'force_directed']


def _process_params(G, center, dim):
    # Some boilerplate code.
    import numpy as np

    if not isinstance(G, nx.Graph):
        empty_graph = nx.Graph()
        empty_graph.add_nodes_from(G)
        G = empty_graph

    if center is None:
        center = np.zeros(dim)
    else:
        center = np.asarray(center)

    if len(center) != dim:
        msg = "length of center coordinates must match dimension of layout"
        raise ValueError(msg)

    return G, center


def random_layout(G, center=None, dim=2):
    """Position nodes uniformly at random in the unit square.

    For every node, a position is generated by choosing each of dim
    coordinates uniformly at random on the interval [0.0, 1.0).

    NumPy (http://scipy.org) is required for this function.

    Parameters
    ----------
    G : NetworkX graph or list of nodes
        A position will be assigned to every node in G.

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.lollipop_graph(4, 3)
    >>> pos = nx.random_layout(G)

    """
    import numpy as np

    G, center = _process_params(G, center, dim)
    shape = (len(G), dim)
    pos = np.random.random(shape) + center
    pos = pos.astype(np.float32)
    pos = dict(zip(G, pos))

    return pos


def circular_layout(G, scale=1, center=None, dim=2):
    # dim=2 only
    """Position nodes on a circle.

    Parameters
    ----------
    G : NetworkX graph or list of nodes

    scale : float
        Scale factor for positions

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout, currently only dim=2 is supported

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.circular_layout(G)

    Notes
    -----
    This algorithm currently only works in two dimensions and does not
    try to minimize edge crossings.

    """
    import numpy as np

    G, center = _process_params(G, center, dim)

    if len(G) == 0:
        pos = {}
    elif len(G) == 1:
        pos = {nx.utils.arbitrary_element(G): center}
    else:
        # Discard the extra angle since it matches 0 radians.
        theta = np.linspace(0, 1, len(G) + 1)[:-1] * 2 * np.pi
        theta = theta.astype(np.float32)
        pos = np.column_stack([np.cos(theta), np.sin(theta)])
        pos = rescale_layout(pos, scale=scale) + center
        pos = dict(zip(G, pos))

    return pos


def shell_layout(G, nlist=None, scale=1, center=None, dim=2):
    """Position nodes in concentric circles.

    Parameters
    ----------
    G : NetworkX graph or list of nodes

    nlist : list of lists
       List of node lists for each shell.

    scale : float
        Scale factor for positions

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout, currently only dim=2 is supported

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> shells = [[0], [1, 2, 3]]
    >>> pos = nx.shell_layout(G, shells)

    Notes
    -----
    This algorithm currently only works in two dimensions and does not
    try to minimize edge crossings.

    """
    import numpy as np

    G, center = _process_params(G, center, dim)

    if len(G) == 0:
        return {}
    if len(G) == 1:
        return {nx.utils.arbitrary_element(G): center}

    if nlist is None:
        # draw the whole graph in one shell
        nlist = [list(G)]

    if len(nlist[0]) == 1:
        # single node at center
        radius = 0.0
    else:
        # else start at r=1
        radius = 1.0

    npos = {}
    for nodes in nlist:
        # Discard the extra angle since it matches 0 radians.
        theta = np.linspace(0, 1, len(nodes) + 1)[:-1] * 2 * np.pi
        theta = theta.astype(np.float32)
        pos = np.column_stack([np.cos(theta), np.sin(theta)])
        pos = rescale_layout(pos, scale=scale * radius / len(nlist)) + center
        npos.update(zip(nodes, pos))
        radius += 1.0

    return npos


def fruchterman_reingold_layout(G, k=None,
                                pos=None,
                                fixed=None,
                                iterations=50,
                                weight='weight',
                                scale=1.0,
                                center=None,
                                dim=2):
    """Position nodes using Fruchterman-Reingold force-directed algorithm.

    Parameters
    ----------
    G : NetworkX graph or list of nodes

    k : float optional (default=None)
        Optimal distance between nodes.  If None the distance is set to
        1/sqrt(n) where n is the number of nodes.  Increase this value
        to move nodes farther apart.

    pos : dict or None  optional (default=None)
        Initial positions for nodes as a dictionary with node as keys
        and values as a coordinate list or tuple.  If None, then use
        random initial positions.

    fixed : list or None  optional (default=None)
        Nodes to keep fixed at initial position.

    iterations : int  optional (default=50)
        Number of iterations of spring-force relaxation

    weight : string or None   optional (default='weight')
        The edge attribute that holds the numerical value used for
        the edge weight.  If None, then all edge weights are 1.

    scale : float optional (default=1.0)
        Scale factor for positions. The nodes are positioned
        in a box of size [0, scale] x [0, scale].

    center : array-like or None optional
        Coordinate pair around which to center the layout.

    dim : optional int
        Dimension of layout

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.fruchterman_reingold_layout(G)
    """
    import numpy as np
    import warnings

    warnings.warn('''fruchterman_reingold_layout is replaced by
                   generalized_fruchterman_reingold_layout or spring_layout''',
                   PendingDeprecationWarning)

    G, center = _process_params(G, center, dim)

    if fixed is not None:
        nfixed = dict(zip(G, range(len(G))))
        fixed = np.asarray([nfixed[v] for v in fixed])

    if pos is not None:
        # Determine size of existing domain to adjust initial positions
        dom_size = max(coord for pos_tup in pos.values() for coord in pos_tup)
        shape = (len(G), dim)
        pos_arr = np.random.random(shape) * dom_size + center
        for i, n in enumerate(G):
            if n in pos:
                pos_arr[i] = np.asarray(pos[n])
    else:
        pos_arr = None

    if len(G) == 0:
        return {}
    if len(G) == 1:
        return {next(G.nodes()): center}

    try:
        # Sparse matrix
        if len(G) < 500:  # sparse solver for large graphs
            raise ValueError
        A = nx.to_scipy_sparse_matrix(G, weight=weight, dtype='f')
        if k is None and fixed is not None:
            # We must adjust k by domain size for layouts not near 1x1
            nnodes, _ = A.shape
            k = dom_size / np.sqrt(nnodes)
        pos = _sparse_fruchterman_reingold(A, k, pos_arr, fixed,
                                           iterations, dim)
    except:
        A = nx.to_numpy_matrix(G, weight=weight)
        if k is None and fixed is not None:
            # We must adjust k by domain size for layouts not near 1x1
            nnodes, _ = A.shape
            k = dom_size / np.sqrt(nnodes)
        pos = _fruchterman_reingold(A, k, pos_arr, fixed, iterations, dim)
    if fixed is None:
        pos = rescale_layout(pos, scale=scale) + center
    pos = dict(zip(G, pos))
    return pos


def _fruchterman_reingold(A, k=None, pos=None, fixed=None,
                          iterations=50, dim=2):
    # Position nodes in adjacency matrix A using Fruchterman-Reingold
    # Entry point for NetworkX graph is fruchterman_reingold_layout()
    try:
        import numpy as np
    except ImportError:
        msg = "_fruchterman_reingold() requires numpy: http://scipy.org/ "
        raise ImportError(msg)

    try:
        nnodes, _ = A.shape
    except AttributeError:
        msg = "fruchterman_reingold() takes an adjacency matrix as input"
        raise nx.NetworkXError(msg)

    # make sure we have an array instead of a matrix
    A = np.asarray(A)

    if pos is None:
        # random initial positions
        pos = np.asarray(np.random.random((nnodes, dim)), dtype=A.dtype)
    else:
        # make sure positions are of same type as matrix
        pos = pos.astype(A.dtype)

    # optimal distance between nodes
    if k is None:
        k = np.sqrt(1.0/nnodes)
    # the initial "temperature"  is about .1 of domain area (=1x1)
    # this is the largest step allowed in the dynamics.
    # We need to calculate this in case our fixed positions force our domain
    # to be much bigger than 1x1
    t = max(max(pos.T[0]) - min(pos.T[0]), max(pos.T[1]) - min(pos.T[1]))*0.1
    # simple cooling scheme.
    # linearly step down by dt on each iteration so last iteration is size dt.
    dt = t/float(iterations+1)
    delta = np.zeros((pos.shape[0], pos.shape[0], pos.shape[1]), dtype=A.dtype)
    # the inscrutable (but fast) version
    # this is still O(V^2)
    # could use multilevel methods to speed this up significantly
    for iteration in range(iterations):
        # matrix of difference between points
        for i in range(pos.shape[1]):
            delta[:, :, i] = pos[:, i, None] - pos[:, i]
        # distance between points
        distance = np.sqrt((delta**2).sum(axis=-1))
        # enforce minimum distance of 0.01
        distance = np.where(distance < 0.01, 0.01, distance)
        # displacement "force"
        displacement = np.transpose(np.transpose(delta) *
                                    (k * k / distance**2 - A * distance / k)
                                    ).sum(axis=1)
        # update positions
        length = np.sqrt((displacement**2).sum(axis=1))
        length = np.where(length < 0.01, 0.1, length)
        delta_pos = np.transpose(np.transpose(displacement) * t / length)
        if fixed is not None:
            # don't change positions of fixed nodes
            delta_pos[fixed] = 0.0
        pos += delta_pos
        # cool temperature
        t -= dt
    return pos


def _sparse_fruchterman_reingold(A, k=None, pos=None, fixed=None,
                                 iterations=50, dim=2):
    # Position nodes in adjacency matrix A using Fruchterman-Reingold
    # Entry point for NetworkX graph is fruchterman_reingold_layout()
    # Sparse version
    try:
        import numpy as np
    except ImportError:
        m = "_sparse_fruchterman_reingold() requires numpy: http://scipy.org/"
        raise ImportError(m)
    try:
        nnodes, _ = A.shape
    except AttributeError:
        msg = "fruchterman_reingold() takes an adjacency matrix as input"
        raise nx.NetworkXError(msg)
    try:
        from scipy.sparse import spdiags, coo_matrix
    except ImportError:
        msg = "_sparse_fruchterman_reingold() scipy numpy: http://scipy.org/ "
        raise ImportError(msg)
    # make sure we have a LIst of Lists representation
    try:
        A = A.tolil()
    except:
        A = (coo_matrix(A)).tolil()

    if pos is None:
        # random initial positions
        pos = np.asarray(np.random.random((nnodes, dim)), dtype=A.dtype)
    else:
        # make sure positions are of same type as matrix
        pos = pos.astype(A.dtype)

    # no fixed nodes
    if fixed is None:
        fixed = []

    # optimal distance between nodes
    if k is None:
        k = np.sqrt(1.0/nnodes)
    # the initial "temperature"  is about .1 of domain area (=1x1)
    # this is the largest step allowed in the dynamics.
    t = 0.1
    # simple cooling scheme.
    # linearly step down by dt on each iteration so last iteration is size dt.
    dt = t / float(iterations+1)

    displacement = np.zeros((dim, nnodes))
    for iteration in range(iterations):
        displacement *= 0
        # loop over rows
        for i in range(A.shape[0]):
            if i in fixed:
                continue
            # difference between this row's node position and all others
            delta = (pos[i] - pos).T
            # distance between points
            distance = np.sqrt((delta**2).sum(axis=0))
            # enforce minimum distance of 0.01
            distance = np.where(distance < 0.01, 0.01, distance)
            # the adjacency matrix row
            Ai = np.asarray(A.getrowview(i).toarray())
            # displacement "force"
            displacement[:, i] +=\
                (delta * (k * k / distance**2 - Ai * distance / k)).sum(axis=1)
        # update positions
        length = np.sqrt((displacement**2).sum(axis=0))
        length = np.where(length < 0.01, 0.1, length)
        pos += (displacement * t / length).T
        # cool temperature
        t -= dt
    return pos


def force_atlas_2_layout(G, k=None,
                         pos=None,
                         fixed=None,
                         iterations=0,
                         weight='weight',
                         scale=1.0,
                         center=None,
                         dim=2,
                         g=0,
                         edge_weight_influence=1,
                         log_attraction=False,
                         dissuade_hubs=False,
                         displacement_min=1,
                         distance=None):
    """Position nodes using the Force Atlas 2 force-directed algorithm.

    Parameters
    ----------
    G : NetworkX graph or list of nodes

    k : float  optional (default=None)
        Scalar to adjust repulsion force. If None it is set to 10 under
        100 nodes else 2. The higher it is, the stronger the repulsion is.

    pos : dict or None  optional (default=None)
        Initial positions for nodes as a dictionary with node as keys
        and values as a coordinate list or tuple.  If None, then use
        random initial positions.

    fixed : list or None  optional (default=None)
        Nodes to keep fixed at initial position.

    iterations : int  optional (default=0)
        Number of maximum iterations. The algorithm stops when the
        maximum displacement is under displacement_min or when the
        number of iterations is reached. If it is 0, then there is no
        limit on the number of iterations. The algorithm is guaranteed
        to converge if displacement_min>0.

    weight : string or None   optional (default='weight')
        The edge attribute that holds the numerical value used for
        the edge weight.  If None, then all edge weights are 1.

    scale : float  optional (default=1.0)
        Scale factor for positions. The nodes are positioned
        in a box of size [0, scale] x [0, scale], unless some nodes are fixed.

    center : array-like or None  optional
        Coordinate pair around which to center the layout.

    dim : int  optional (default=2)
        Dimension of layout

    g : float  optional (default=0)
        Scalar to adjust "gravity" force. The higher it is, the more nodes
        are attracted to the center. "Gravity" is a linear function of
        distance power by g.

    edge_weight_influence : float  optional (default=1)
        If the edges are weighted (edges must have a 'weight' attribute),
        attraction is a linear function of distance multiplied by the weight
        to the power of edge_weight_influence (unless log_attraction is True).

    log_attraction : boolean  optional (default=False)
        Use logarithm attraction force instead of proportionnal.

    dissuade_hubs : boolean  optional (default=False)
        Divide the attraction by the number of outgoing links plus one.

    displacement_min : float  optional (default=1)
        The algorithm stops if an iteration would make the node that moves the
        most move less than displacement_min.
        The default of one pixel makes a lot of sense. Values < 1 will lead to
        much slower convergence.

    distance : function  optional (default=None)
        Function that take an _ x dim array of deltas between
        coordinates and return the _ array of the scalar distances
        corresponding to those deltas.
        Defaults to lambda x: np.linalg.norm(x, axis=-1) if None.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    FIXME: Regarder les tests ailleurs
    >>> G = nx.path_graph(4)
    >>> pos = nx.force_atlas_2_layout(G)

    See also
    --------
    generalized_fruchterman_reingold_layout
    force_directed  # FIXME: Changer les noms des fonctions
    """
    import numpy as np

    G, center = _process_params(G, center, dim)

    W = np.asarray(nx.to_numpy_matrix(G, weight=weight))**edge_weight_influence
    A = np.where(W, 1, 0)
    nnodes, _ = A.shape

    if nnodes == 0:
        return {}

    if not k:
        # Default values inspired from Force Atlas 2 Java implementation
        k = 2 if nnodes > 100 else 10

    if len(G) > 5000:
        raise NotImplementedError("Sparse matrix Force Atlas 2 is not "
                                  "implemented yet")

    ones = np.ones((nnodes, 1))

    # ∀ x, Hub[i, x] is 1 + the number of outgoing edges from node i
    Hub = np.matmul((1 + np.sum(A, axis=1)).reshape((nnodes, 1)), ones.T)
    # Hub times 1 + the number of incoming edges is used as the degree in
    # Force Atlas 2. It has the nice property of never being 0.
    Deg = Hub * np.matmul(ones, (1 + np.sum(A, axis=0)).reshape((1, nnodes)))

    def force_atlas_2(Dis, Δ_unit, Pos, distance=None):
        """Return the n x dim displacement vector for Force Atlas 2.

        The forces are computed according to the paper

        Jacomy, M., Venturini, T., Heymann, S., & Bastian, M. (2014).
        ForceAtlas2, a continuous graph layout algorithm for handy network
        visualization designed for the Gephi software.

        Parameters
        ----------
        Dis : n x n array-like
            Dis[i, j] is the scalar distance between i and j

        Δ_unit : n x n x dim array-like
            Δ_unit[i, j] is the unit vector pointing from i to j

        Pos : n x dim array-like
            Pos[i] is the position of node i

        distance : function  optional (default=None)
            Function that take an _ x dim array of deltas between
            coordinates and return the _ array of the scalar distances
            corresponding to those deltas.
            Defaults to lambda x: np.linalg.norm(x, axis=-1) if None.
        """
        if distance is None:
            Dis_center = np.linalg.norm(Pos, axis=-1)
        else:
            Dis_center = distance(Pos)
        Dis_center = np.where(Dis_center < 0.01, 0.01, Dis_center)
        f_gra = Hub[0] * Dis_center**g
        f_gra = f_gra.reshape(nnodes, 1) * Pos / Dis_center.reshape(nnodes, 1)

        f_rep = k * Deg / Dis
        f_rep = f_rep.reshape(nnodes, nnodes, 1) * Δ_unit

        if log_attraction:
            f_att = np.log(Dis) * W
        else:
            f_att = Dis * W
        if dissuade_hubs:
            f_att /= Hub
        f_att = f_att.reshape((nnodes, nnodes, 1)) * Δ_unit

        return np.sum(f_att - f_rep, axis=1) - f_gra

    Pos = nx.force_directed(G, force_atlas_2, pos, fixed, iterations, scale,
                            center, dim, displacement_min)
    pos = dict(zip(G, Pos))
    return pos


def generalized_fruchterman_reingold_layout(G, k=None,
                                            pos=None,
                                            fixed=None,
                                            iterations=0,
                                            weight='weight',
                                            scale=1.0,
                                            center=None,
                                            dim=2,
                                            displacement_min=1,
                                            distance=None):
    """Position nodes using Fruchterman-Reingold force-directed algorithm.

    Parameters
    ----------
    G : NetworkX graph or list of nodes

    k : float (default=None)
        Optimal distance between nodes.  If None the distance is set to
        1/sqrt(n) where n is the number of nodes.  Increase this value
        to move nodes farther apart.

    pos : dict or None  optional (default=None)
        Initial positions for nodes as a dictionary with node as keys
        and values as a coordinate list or tuple.  If None, then use
        random initial positions.

    fixed : list or None  optional (default=None)
        Nodes to keep fixed at initial position.

    iterations : int  optional (default=0)
        Number of maximum iterations. The algorithm stops when the
        maximum displacement is under displacement_min or when the
        number of iterations is reached. If it is 0, then there is no
        limit on the number of iterations. The algorithm is guaranteed
        to converge if displacement_min>0.

    weight : string or None   optional (default='weight')
        The edge attribute that holds the numerical value used for
        the edge weight.  If None, then all edge weights are 1.

    scale : float (default=1.0)
        Scale factor for positions. The nodes are positioned
        in a box of size [0, scale] x [0, scale].

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int  optional (default=2)
        Dimension of layout

    displacement_min : float  optional (default=1)
        The algorithm stops if an iteration would make the node that moves the most
        move less than displacement_min.
        The default of one pixel makes a lot of sense. Values < 1 will lead to
        much slower convergence.

    distance : function  optional (default=None)
        Function that take an n x n x dim array of deltas between
        coordinates and return the n x n array of the scalar distances
        corresponding to those deltas.
        Defaults to lambda x: np.linalg.norm(x, axis=-1) if None.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.spring_layout(G)

    # The same using longer but equivalent function name
    >>> pos = nx.generalized_fruchterman_reingold_layout(G)

    See also
    --------
    force_atlas_2_layout
    force_directed
    """
    import numpy as np

    if len(G) == 0:
        return {}
    elif len(G) >= 500:  # Using old implementation, which will call the
        # "sparse" version
        return fruchterman_reingold_layout(G, k, pos, fixed, iterations,
                                           weight, scale, center, dim)

    W = np.asarray(nx.to_numpy_matrix(G, weight=weight))
    A = np.where(W, 1, 0)
    nnodes, _ = A.shape

    if k is None:
        if fixed is not None:
            dom_size = max(coord for pos_tup in pos.values()
                           for coord in pos_tup)
            # We must adjust k by domain size for layouts not near 1x1
            k = dom_size / np.sqrt(nnodes)
        else:
            k = np.sqrt(1.0/nnodes)

    def fruchterman_reingold(Dis, Δ_unit, Pos, _):
        """Return the n x dim displacement vector for Fruchterman Reingold.

        The forces are computed according to the paper

        Thomas M. J. Fruchterman AND Edward M. Reingold (1991)
        Graph Drawing by Force-directed Placement

        Parameters
        ----------
        Dis : n x n array-like
            Dis[i, j] is the scalar distance between i and j

        Δ_unit : n x n x dim array-like
            Δ_unit[i, j] is the unit vector pointing from i to j

        Pos : n x dim array-like
            Pos[i] is the position of node i

        _ : Some algos (e.g. Force Atlas 2) need to know the distance
            function, we dont.
        """
        f_rep = (k * k / Dis**2).reshape((nnodes, nnodes, 1)) * Δ_unit

        f_att = (W * Dis / k).reshape((nnodes, nnodes, 1)) * Δ_unit

        return np.sum(f_att - f_rep, axis=1)

    pos = nx.force_directed(G, fruchterman_reingold, pos, fixed,
                            iterations, scale, center, dim,
                            displacement_min, distance)

    pos = dict(zip(G, pos))
    return pos


spring_layout = generalized_fruchterman_reingold_layout


def force_directed(G, get_displacement,
                   pos=None,
                   fixed=None,
                   iterations=0,
                   scale=1.0,
                   center=None,
                   dim=2,
                   displacement_min=1,
                   distance=None):
    """Run a force-directed algorithm on G, using the given set of forces.

    G : NetworkX graph or list of nodes

    get_displacement : function of Dis, Δ_unit, Pos, distance, where:
        - Dis is a n x n array-like, Dis[i, j] is the scalar distance
          between node i and node j,
        - Δ_unit: n x n x dim array-like, Δ_unit[i, j] is the unit vector
          pointing from i to j,
        - Pos: n x dim array-like, Pos[i] is the position of i,
        - distance: function  that take an _ x dim array of deltas between
            coordinates and return the _ array of the scalar distances
            corresponding to those deltas.

        get_displacement computes the displacement for one iteration from
        its arguments by computing and summing the forces. See for example
        :py:func:`networkx.layout.force_atlas_2_layout.force_atlas2` or
        :py:func:`networkx.layout.generalized_fruchterman_reingold_layout.fruchterman_reingold`.

    pos : dict or None  optional (default=None)
        Initial positions for nodes as a dictionary with node as keys
        and values as a coordinate list or tuple.  If None, then use
        random initial positions.

    fixed : list or None  optional (default=None)
        Nodes to keep fixed at initial position.

    iterations : int  optional (default=0)
        Number of maximum iterations. The algorithm stops when the
        maximum displacement is under displacement_min or when the
        number of iterations is reached. If it is 0, then there is no
        limit on the number of iterations. The algorithm is guaranteed
        to converge if displacement_min>0.

    scale : float  optional (default=1.0)
        Scale factor for positions. The nodes are positioned
        in a box of size [0, scale] x [0, scale].

    center : array-like or None  optional
        Coordinate pair around which to center the layout.

    dim : int  optional (default=2)
        Dimension of layout

    displacement_min : float  optional (default=1)
        The algorithm stops if an iteration would make the node that moves the most
        move less than displacement_min.
        The default of one pixel makes a lot of sense. Values < 1 will lead to
        much slower convergence.

    distance : function  optional (default=None)
        Function that take an n x n x dim array of deltas between
        coordinates and return the n x n array of the scalar distances
        corresponding to those deltas.
        Defaults to lambda x: np.linalg.norm(x, axis=-1) if None.

    Returns
    -------
    pos : n x dim array-like
        An array of positions of nodes.

    See also
    --------
    force_atlas_2_layout
    generalized_fruchterman_reingold_layout
    """
    try:
        import numpy as np
    except ImportError:
        msg = "force_directed() requires numpy: http://scipy.org/ "
        raise ImportError(msg)

    G, center = _process_params(G, center, dim)

    if iterations == 0:
        iterations = np.inf

    nnodes = len(G)

    shape = (nnodes, dim)
    if pos:
        # Determine size of existing domain to adjust initial positions
        dom_size = max(coord for pos_tup in pos.values() for coord in pos_tup)
        Pos = np.random.random(shape) * dom_size + center
        for i, n in enumerate(G):
            if n in pos:
                Pos[i] = np.asarray(pos[n])
    else:
        Pos = np.random.random(shape) + center

    if nnodes == 0:
        return None
    if nnodes == 1:
        return [center]

    if distance is None:
        def distance(x):
            '''Take an n x n x dim array of deltas between
            coordinates and return the n x n array of the scalar distances
            corresponding to those deltas.'''
            return np.linalg.norm(x, axis=-1)

    def deltas(Pos):
        '''Return the n x n array Δ of dim-dimensional vectors between nodes.

        Δ[i, j, k] is the delta along dimension k between nodes i and j,
        therefore:
        - Δ[i, j k] == - Δ[j, i, k],
        - Pos[i] + Δ[i, j] == Pos[j]
        - and distance bewteen i and j is distance(Δ[i, j,:])

        Parameters
        -----------
        Pos: n x dim array-like
            The nodes' positions

        Returns
        --------
        The n x n x dim delta array.
        '''
        p1_pn_in_lines = np.tensordot(ones, Pos.reshape(1, nnodes, dim), 1)
        assert p1_pn_in_lines.shape == (nnodes, nnodes, dim),\
            """p1_pn_in_lines is supposed to be the matrix whose lines are
            Pos, transposed a way that leaves its dim-dimensional elements
            (the nodes positions) untouched"""
        # By substracting its transpose to it, we compute the deltas
        return p1_pn_in_lines - p1_pn_in_lines.transpose(1, 0, 2)

    ones = np.ones((nnodes, 1))

    M = np.array([[1] if not fixed or node not in fixed else [0]
                  for node in G])

    Pos_changed = True  # We only recompute δa nd Q if the positions changed
    Q = np.inf
    α = 1
    i = 0
    while i < iterations:
        i += 1
        if Pos_changed:
            Δ = deltas(Pos)
            Dis = distance(Δ)
            Dis = np.where(Dis < 0.01, 0.01, Dis)
            Δ_unit = Δ / Dis.reshape((nnodes, nnodes, 1))
            δ = get_displacement(Dis, Δ_unit, Pos, distance) * M
            Pos_changed = False
        Pos_2 = Pos + δ * α
        Δ_2 = deltas(Pos_2)
        Dis_2 = distance(Δ_2)
        Dis_2 = np.where(Dis_2 < 0.01, 0.01, Dis_2)
        Δ_unit_2 = Δ_2 / Dis_2.reshape((nnodes, nnodes, 1))
        δ_2 = get_displacement(Dis_2, Δ_unit_2, Pos_2, distance) * M
        Q_2 = np.linalg.norm(δ_2)
        if Q != np.inf:
            α = α * Q / Q_2
        if Q_2 < Q:
            Q = Q_2
            Pos = Pos_2
            Pos_changed = True
        else:
            α /= 2
        if max(map(np.max, map(np.abs, δ * α))) <= displacement_min:
            break
    if fixed is None:
        Pos = nx.rescale_layout(Pos, scale=scale) + center
    return Pos


def spectral_layout(G, weight='weight', scale=1, center=None, dim=2):
    """Position nodes using the eigenvectors of the graph Laplacian.

    Parameters
    ----------
    G : NetworkX graph or list of nodes

    weight : string or None   optional (default='weight')
        The edge attribute that holds the numerical value used for
        the edge weight.  If None, then all edge weights are 1.

    scale : float
        Scale factor for positions

    center : array-like or None
        Coordinate pair around which to center the layout.

    dim : int
        Dimension of layout

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    Examples
    --------
    >>> G = nx.path_graph(4)
    >>> pos = nx.spectral_layout(G)

    Notes
    -----
    Directed graphs will be considered as undirected graphs when
    positioning the nodes.

    For larger graphs (>500 nodes) this will use the SciPy sparse
    eigenvalue solver (ARPACK).
    """
    # handle some special cases that break the eigensolvers
    import numpy as np

    G, center = _process_params(G, center, dim)

    if len(G) <= 2:
        if len(G) == 0:
            pos = np.array([])
        elif len(G) == 1:
            pos = np.array([center])
        else:
            pos = np.array([np.zeros(dim), np.array(center)*2.0])
        return dict(zip(G, pos))
    try:
        # Sparse matrix
        if len(G) < 500:  # dense solver is faster for small graphs
            raise ValueError
        A = nx.to_scipy_sparse_matrix(G, weight=weight, dtype='d')
        # Symmetrize directed graphs
        if G.is_directed():
            A = A + np.transpose(A)
        pos = _sparse_spectral(A, dim)
    except (ImportError, ValueError):
        # Dense matrix
        A = nx.to_numpy_matrix(G, weight=weight)
        # Symmetrize directed graphs
        if G.is_directed():
            A = A + np.transpose(A)
        pos = _spectral(A, dim)

    pos = rescale_layout(pos, scale) + center
    pos = dict(zip(G, pos))
    return pos


def _spectral(A, dim=2):
    # Input adjacency matrix A
    # Uses dense eigenvalue solver from numpy
    try:
        import numpy as np
    except ImportError:
        msg = "spectral_layout() requires numpy: http://scipy.org/ "
        raise ImportError(msg)
    try:
        nnodes, _ = A.shape
    except AttributeError:
        msg = "spectral() takes an adjacency matrix as input"
        raise nx.NetworkXError(msg)

    # form Laplacian matrix
    # make sure we have an array instead of a matrix
    A = np.asarray(A)
    I = np.identity(nnodes, dtype=A.dtype)
    D = I * np.sum(A, axis=1)  # diagonal of degrees
    L = D - A

    eigenvalues, eigenvectors = np.linalg.eig(L)
    # sort and keep smallest nonzero
    index = np.argsort(eigenvalues)[1:dim + 1]  # 0 index is zero eigenvalue
    return np.real(eigenvectors[:, index])


def _sparse_spectral(A, dim=2):
    # Input adjacency matrix A
    # Uses sparse eigenvalue solver from scipy
    # Could use multilevel methods here, see Koren "On spectral graph drawing"
    try:
        import numpy as np
        from scipy.sparse import spdiags
    except ImportError:
        msg = "_sparse_spectral() requires scipy & numpy: http://scipy.org/ "
        raise ImportError(msg)
    try:
        from scipy.sparse.linalg.eigen import eigsh
    except ImportError:
        # scipy <0.9.0 names eigsh differently
        from scipy.sparse.linalg import eigen_symmetric as eigsh
    try:
        nnodes, _ = A.shape
    except AttributeError:
        msg = "sparse_spectral() takes an adjacency matrix as input"
        raise nx.NetworkXError(msg)

    # form Laplacian matrix
    data = np.asarray(A.sum(axis=1).T)
    D = spdiags(data, 0, nnodes, nnodes)
    L = D - A

    k = dim + 1
    # number of Lanczos vectors for ARPACK solver.What is the right scaling?
    ncv = max(2 * k + 1, int(np.sqrt(nnodes)))
    # return smallest k eigenvalues and eigenvectors
    eigenvalues, eigenvectors = eigsh(L, k, which='SM', ncv=ncv)
    index = np.argsort(eigenvalues)[1:k]  # 0 index is zero eigenvalue
    return np.real(eigenvectors[:, index])


def rescale_layout(pos, scale=1):
    """Return scaled position array to (-scale, scale) in all axes.

    The function acts on NumPy arrays which hold position information.
    Each position is one row of the array. The dimension of the space
    equals the number of columns. Each coordinate in one column.

    To rescale, the mean (center) is subtracted from each axis separately.
    Then all values are scaled so that the largest magnitude value
    from all axes equals `scale` (thus, the aspect ratio is preserved).
    The resulting NumPy Array is returned (order of rows unchanged).

    Parameters
    ----------
    pos : numpy array
        positions to be scaled. Each row is a position.

    scale : number (default: 1)
        The size of the resulting extent in all directions.

    Returns
    -------
    pos : numpy array
        scaled positions. Each row is a position.

    """
    # Find max length over all dimensions
    lim = 0  # max coordinate for all axes
    for i in range(pos.shape[1]):
        pos[:, i] -= pos[:, i].mean()
        lim = max(pos[:, i].max(), lim)
    # rescale to (-scale, scale) in all directions, preserves aspect
    if lim > 0:
        for i in range(pos.shape[1]):
            pos[:, i] *= scale / lim
    return pos


# fixture for nose tests
def setup_module(module):
    from nose import SkipTest
    try:
        import numpy
    except:
        raise SkipTest("NumPy not available")
    try:
        import scipy
    except:
        raise SkipTest("SciPy not available")
