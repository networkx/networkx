"""Hypothesis strategies for generating NetworkX graphs with edge attributes."""

import inspect

from hypothesis import strategies as st

import networkx as nx

__all__ = ["edge_data_st", "graph_st"]


@st.composite
def edge_data_st(draw, **kwargs):
    """Draws a dictionary of edge attributes based on provided strategies.

    Parameters
    ----------
    **kwargs : dict
        Keyword arguments where each value is either:
        - A `hypothesis` strategy (e.g., `st.integers()`)
        - A constant value

    Returns
    -------
    dict
        A dictionary where each key maps to a drawn value or static value.

    Examples
    --------
    >>> from hypothesis import strategies as st
    >>> edge_data_st(weight=st.integers(1, 10), label="A")
    edge_data_st(label='A', weight=integers(min_value=1, max_value=10))
    """
    return {
        k: draw(v) if isinstance(v, st.SearchStrategy) else v for k, v in kwargs.items()
    }


@st.composite
def graph_st(draw, graph_generator, *, edge_data_st=None, **kwargs) -> nx.Graph:
    """Draws a NetworkX graph from a generator function and optionally adds edge data.
    If the generator function accepts a 'seed' parameter, it will be automatically
    generated unless provided in `kwargs`.
    The edge attributes are generated using the `edge_data_st` strategy.

    All graph generators from NetworkX are off-the-shelf supported. For more details,
    see the `generators module documentation <https://networkx.org/documentation/stable/reference/generators.html>`_.
    For more details on the hypothesis framework, see library `documentation <https://hypothesis.readthedocs.io>`_.

    Parameters
    ----------
    graph_generator : callable
        A function that returns a NetworkX graph (e.g., `nx.erdos_renyi_graph`, `nx.random_labeled_tree`).
        In case of being a random generator, it must accept a `seed` parameter to ensure reproducibility.

    edge_data_st : SearchStrategy or constant value, optional
        If constant value is passsed, it will be used as the edge attribute for all edges.
        If a `hypothesis` strategy is passed, it will be used to generate edge attributes (typically created by `edge_data_st(...)`).

    **kwargs : dict
        Additional arguments passed to `graph_generator`. Each argument may be:
        - A `hypothesis` strategy
        - A constant value

    Returns
    -------
    networkx.Graph
        A graph instance generated by the given function, with edge attributes optionally added.

    Examples
    --------
    >>> from hypothesis import strategies as st
    >>> from hypothesis import given

    Using a random generator:

    >>> @given(
    ...     graph_st(
    ...         nx.erdos_renyi_graph,
    ...         n=st.integers(5, 10),
    ...         p=st.floats(0.1, 0.5),
    ...         edge_data_st=edge_data_st(weight=st.integers(1, 100)),
    ...     )
    ... )
    ... def test_weighted_erdos_renyi(G):
    ...     for u, v, d in G.edges(data=True):
    ...         assert "weight" in d

    Using a deterministic generator:

    >>> @given(graph_st(nx.path_graph, n=st.integers(2, 20)))
    ... def test_path_graph(G):
    ...     assert nx.diameter(G) == G.number_of_nodes() - 1

    Other supported examples:

    - Balanced trees:
      >>> strat = graph_st(nx.balanced_tree, r=st.integers(2, 3), h=st.integers(1, 4))

    - Grid graphs:
      >>> strat = graph_st(nx.grid_2d_graph, m=st.integers(2, 4), n=st.integers(2, 4))

    - Complete graphs:
      >>> strat = graph_st(
      ...     nx.complete_graph,
      ...     n=st.integers(1, 10),
      ...     edge_data_st=edge_data_st(val=st.just(1)),
      ... )

    - Small-world and scale-free graphs:
      >>> strat = graph_st(
      ...     nx.watts_strogatz_graph,
      ...     n=st.integers(10, 30),
      ...     k=st.integers(2, 6),
      ...     p=st.floats(0, 1),
      ... )
      >>> strat = graph_st(
      ...     nx.barabasi_albert_graph, n=st.integers(10, 30), m=st.integers(1, 5)
      ... )
    """
    # Prepare parameters for the graph generator
    params = {}
    signature = inspect.signature(graph_generator)

    # If the graph generator accepts a 'seed' and none is provided, generate one
    if "seed" not in kwargs and "seed" in signature.parameters:
        params["seed"] = draw(st.randoms())

    for k, v in kwargs.items():
        params[k] = draw(v) if isinstance(v, st.SearchStrategy) else v

    G = graph_generator(**params)

    # Optionally add edge attributes using the provided strategy
    if edge_data_st is not None:
        for u, v in G.edges():
            G[u][v].update(draw(edge_data_st))

    # Set the graph's pretty representation to improve hypothesis output
    G._repr_pretty_ = lambda p, cycle: graph_repr_pretty(G, p, cycle)
    return G


def graph_repr_pretty(G, p, cycle):
    """
    Custom pretty-printing function for NetworkX graph objects.

    This method formats the graph `G` in a human-readable way for pretty printing,
    using the `pretty` library. It generates a string representation of the graph
    using `nx.from_edgelist` with the appropriate graph type and edge data if available.

    This method is used in conjunction with the Hypothesis framework, which leverages
    the `_repr_pretty_` method to generate clear string representations of graph
    structures, helping to provide visibility into edge cases and falsifying examples
    that do not meet the desired properties or invariants.

    Args:
        G (networkx.Graph): The graph object to be pretty-printed.
        p (pretty.Printer): The printer object used to build the string output.
        cycle (bool): A flag indicating whether there is a cycle in the graph.
                      If `True`, a shortened representation is generated.

    Returns:
        None: This method modifies the output via the `p` printer directly.
    """
    assert not cycle, (
        "Method is not calling pprint so it is impossible to have a pprint call cycle"
    )

    p.text("nx.from_edgelist([")

    for i, (u, v, data) in enumerate(G.edges(data=True)):
        if i > 0:
            p.text(",")
            p.breakable()
        if data:
            p.text(f"({repr(u)}, {repr(v)}, {repr(data)})")
        else:
            p.text(f"({repr(u)}, {repr(v)})")

    p.text("]")
    if type(G) is not nx.Graph:
        # If the graph is not default type Graph, we need to pass create_using
        p.text(",")
        p.breakable()
        p.text(f"create_using=nx.{type(G).__name__}")
    p.text(")")
